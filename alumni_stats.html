<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BSCS Alumni — Stats & Charts (updated)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 18px; color:#222 }
    h1,h2 { margin: 8px 0; }
    .charts { display:flex; flex-wrap:wrap; gap:24px; }
    .chart-card { flex: 1 1 480px; min-width:320px; padding:12px; border:1px solid #e0e0e0; border-radius:8px; background:#fafafa; }
    canvas { width:100% !important; height:320px !important; }
    table { border-collapse: collapse; width:100%; margin-top:12px }
    th,td { text-align:left; padding:6px 8px; border-bottom:1px solid #eee; font-size:14px; }
    .note { font-size:13px; color:#555; margin-top:12px; }
    .loader { color:#666; margin-top:12px; }
    pre.small { font-size:12px; color:#666; background:#f8f8f8; padding:8px; border-radius:6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <h1>BSCS Alumni — Summary (updated rules)</h1>
  <p class="note">
    Data loaded from the CSV in this repo (commit: 12904fe4...). Classification rules updated per your instructions:
    - The script prefers the "status 2 years after graduation" column (flexible matching) to determine employed status.
    - The "position" column is used as the job description to decide whether a job is related to computer science.
    - If "No. of Employment" is non-zero and the status column value is "employed", that alumni is treated as employed.
    - "Research assistant" at MSU-IIT is explicitly counted as related to computer science.
  </p>

  <div id="status" class="loader">Loading and processing CSV — please wait...</div>

  <div class="charts" id="charts" style="display:none">
    <div class="chart-card">
      <h2>Graduates per Academic Year & Semester</h2>
      <canvas id="graduatesChart"></canvas>
    </div>

    <div class="chart-card">
      <h2>Employment status per Academic Year & Semester</h2>
      <canvas id="employmentStackedChart"></canvas>
    </div>

    <div class="chart-card">
      <h2>Employed: Related to CS vs Not related (overall)</h2>
      <canvas id="relatedChart"></canvas>
    </div>
  </div>

  <div id="tables" style="display:none; margin-top:18px">
    <h2>Raw counts</h2>
    <div id="countsTable"></div>
  </div>

<script>
(() => {
  const csvUrl = 'https://raw.githubusercontent.com/liezcd/cs_alumnitracerdata/refs/heads/main/BSCSAlumniTracerData_consolidated.csv?token=GHSAT0AAAAAADQ5UIO2ZFYK5H5P7BJSWL322JZAFKQ';
  const statusEl = document.getElementById('status');

  // Heuristic keyword lists
  const pursuingKeywords = ['pursu', 'further', 'graduate school', 'master', 'ms.', 'ms ', 'msc', 'phd', 'postgrad', 'post-grad', 'continuing education'];
  const employedKeywords = ['employed','employment','work at','works at','hired','working','job','position','company','employ'];
  const csRelatedKeywords = [
    'software','developer','engineer','programmer','it','information technology','computer','data','web','frontend','backend','full-stack','full stack',
    'system','systems','devops','mobile','android','ios','qa','quality assurance','research assistant','researcher','msu-iit','msu iit','msuiit','ai','machine learning','ml','data scientist'
  ];

  // Helper: find a CSV field key by regex
  function findKeyByRegex(row, regexes) {
    const keys = Object.keys(row);
    for (const k of keys) {
      const kn = k ? k.toLowerCase().trim() : '';
      for (const re of regexes) {
        if (typeof re === 'string') {
          if (kn.includes(re)) return k;
        } else {
          if (kn.match(re)) return k;
        }
      }
    }
    return null;
  }

  function getFieldValue(row, regexes) {
    const key = findKeyByRegex(row, regexes);
    if (!key) return '';
    return (row[key] || '').toString().trim();
  }

  // Specific field detectors (flexible)
  const statusFieldRegexes = [
    /status.*2.*year/,
    /status.*after.*graduation/,
    /status.*2.*years/,
    /\bstatus\b/,
    /\b(employment status|current status)\b/
  ];
  const positionFieldRegexes = [
    /\bposition\b/,
    /\bjob\b/,
    /job.*description/,
    /position.*title/,
    /occupation/
  ];
  const noEmploymentFieldRegexes = [
    /no.*of.*employment/,
    /no\.*\s*employment/,
    /number.*employment/,
    /no\.*employment/,
    /\bno\s*of\s*employment\b/
  ];

  // Keyword checks
  function containsAny(text, keywords) {
    if (!text) return false;
    const t = text.toLowerCase();
    return keywords.some(k => t.includes(k));
  }

  function isPursuing(text) {
    return containsAny(text, pursuingKeywords);
  }

  function isEmployedByText(text) {
    if (!text) return false;
    const t = text.toLowerCase();
    if (t.includes('employed')) return true;
    return employedKeywords.some(k => t.includes(k));
  }

  function isRelatedToCSByText(text) {
    if (!text) return false;
    const t = text.toLowerCase();

    // explicit rule: research assistant at MSU-IIT counts as related
    if (t.includes('research assistant') && (t.includes('msu-iit') || t.includes('msuiit') || t.includes('msu iit'))) return true;

    return containsAny(t, csRelatedKeywords);
  }

  function parseIntSafe(n) {
    if (!n) return 0;
    const digits = n.toString().replace(/[^0-9\-]/g, '');
    const v = parseInt(digits, 10);
    return isNaN(v) ? 0 : v;
  }

  // Fallback groupKey same as before
  function groupKey(row) {
    const ayCandidates = ['Academic Year','Graduation','Graduation,Academic Year','Graduation/Academic Year'];
    let ay = '';
    for (const k of Object.keys(row)) {
      const kn = k.toLowerCase();
      if (kn.includes('academic year') || kn.includes('graduation') && kn.match(/\d{4}/)) {
        ay = (row[k] || '').toString().trim();
        if (ay) break;
      }
    }
    if (!ay) {
      // last resort, try first cell
      const firstKey = Object.keys(row)[0];
      ay = row[firstKey] || '';
    }
    const semKey = findKeyByRegex(row, ['semester','sem']);
    const semester = semKey ? (row[semKey]||'').toString().trim() : '';
    const label = (ay ? ay : 'Unknown') + (semester ? ' (Sem ' + semester + ')' : '');
    return { academicYear: ay, semester: semester, label: label, key: (ay||'Unknown') + '|' + (semester||'') };
  }

  Papa.parse(csvUrl, {
    download: true,
    header: true,
    skipEmptyLines: true,
    complete: function(results) {
      const rows = results.data;
      statusEl.textContent = `CSV loaded: ${rows.length} rows. Computing aggregates with updated rules...`;

      // Build groups
      const groups = {};
      rows.forEach(row => {
        const {academicYear, semester, label, key} = groupKey(row);
        if (!groups[key]) {
          groups[key] = {
            academicYear: academicYear || 'Unknown',
            semester: semester || '',
            label: label,
            total: 0,
            employed: 0,
            pursuing: 0,
            unemployed: 0,
            relatedEmployed: 0,
            notRelatedEmployed: 0
          };
        }
        const item = groups[key];
        item.total += 1;

        // Extract specific fields
        const statusVal = (getFieldValue(row, statusFieldRegexes) || '').toLowerCase();
        const positionVal = getFieldValue(row, positionFieldRegexes) || '';
        const noOfEmploymentVal = getFieldValue(row, noEmploymentFieldRegexes) || '';
        const noOfEmployment = parseIntSafe(noOfEmploymentVal);

        // Determine employed per your rule:
        // If No. of Employment is non-zero AND status column is 'employed' => employed
        let employedFlag = false;
        if (noOfEmployment > 0 && statusVal.includes('employ')) {
          employedFlag = true;
        } else {
          // Otherwise fallback to heuristics: either status text says employed or row contains employment hints
          if (statusVal && statusVal.includes('employ')) employedFlag = true;
          else {
            // Look for employed words in the row and in specific position/company fields
            const combinedRowText = Object.values(row).join(' ').toLowerCase();
            if (isEmployedByText(positionVal) || isEmployedByText(combinedRowText)) employedFlag = true;
          }
        }

        // Determine pursuing flag
        let pursuingFlag = false;
        const combinedText = Object.values(row).join(' ').toLowerCase();
        if (isPursuing(statusVal) || isPursuing(positionVal) || isPursuing(combinedText)) pursuingFlag = true;

        if (employedFlag) {
          item.employed += 1;
          // Determine relatedness: prefer 'position' column, otherwise fallback to full row text
          const related = (positionVal && isRelatedToCSByText(positionVal)) || isRelatedToCSByText(combinedText);
          if (related) item.relatedEmployed += 1;
          else item.notRelatedEmployed += 1;
        } else if (pursuingFlag) {
          item.pursuing += 1;
        } else {
          // explicit unemployed in text?
          if (combinedText.includes('unemployed')) item.unemployed += 1;
          else item.unemployed += 1; // default to unemployed when not employed/pursuing
        }
      });

      // Sort groups
      const groupArray = Object.values(groups);
      function parseAcademicYearStart(ay) {
        const m = (ay||'').match(/(\d{4})/);
        return m ? parseInt(m[1],10) : 0;
      }
      groupArray.sort((a,b) => {
        const ya = parseAcademicYearStart(a.academicYear);
        const yb = parseAcademicYearStart(b.academicYear);
        if (ya !== yb) return ya - yb;
        const sa = parseInt(a.semester||'0',10) || 0;
        const sb = parseInt(b.semester||'0',10) || 0;
        return sa - sb;
      });

      // Chart data
      const labels = groupArray.map(g => g.label);
      const totals = groupArray.map(g => g.total);
      const employedCounts = groupArray.map(g => g.employed);
      const pursuingCounts = groupArray.map(g => g.pursuing);
      const unemployedCounts = groupArray.map(g => g.unemployed);
      const relatedCounts = groupArray.reduce((sum,g) => sum + g.relatedEmployed, 0);
      const notRelatedCounts = groupArray.reduce((sum,g) => sum + g.notRelatedEmployed, 0);

      // Render
      document.getElementById('charts').style.display = '';
      document.getElementById('tables').style.display = '';
      statusEl.style.display = 'none';

      // Graduates per group
      const ctx1 = document.getElementById('graduatesChart').getContext('2d');
      new Chart(ctx1, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Graduates',
            data: totals,
            backgroundColor: 'rgba(54,162,235,0.7)'
          }]
        },
        options: { responsive:true, plugins:{legend:{display:false}} }
      });

      // Stacked employment status per group
      const ctx2 = document.getElementById('employmentStackedChart').getContext('2d');
      new Chart(ctx2, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            { label:'Employed', data: employedCounts, backgroundColor:'rgba(75,192,192,0.8)' },
            { label:'Unemployed - pursuing further studies', data: pursuingCounts, backgroundColor:'rgba(255,205,86,0.9)' },
            { label:'Unemployed', data: unemployedCounts, backgroundColor:'rgba(255,99,132,0.8)' }
          ]
        },
        options: {
          responsive:true,
          plugins:{tooltip:{mode:'index',intersect:false}},
          scales: { x: { stacked: true }, y: { stacked: true, beginAtZero:true } }
        }
      });

      // Related vs Not related (overall)
      const ctx3 = document.getElementById('relatedChart').getContext('2d');
      new Chart(ctx3, {
        type: 'pie',
        data: {
          labels: ['Related to CS', 'Not related to CS'],
          datasets: [{
            data: [relatedCounts, notRelatedCounts],
            backgroundColor: ['rgba(54,162,235,0.85)','rgba(201,203,207,0.85)']
          }]
        },
        options: { responsive:true }
      });

      // Table of counts per group
      const tableWrap = document.getElementById('countsTable');
      const tbl = document.createElement('table');
      const header = document.createElement('thead');
      header.innerHTML = '<tr><th>Academic Year</th><th>Semester</th><th>Total</th><th>Employed</th><th>Employed (related)</th><th>Employed (not related)</th><th>Unemployed pursuing</th><th>Unemployed</th></tr>';
      tbl.appendChild(header);
      const body = document.createElement('tbody');
      groupArray.forEach(g => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${g.academicYear}</td><td>${g.semester || '-'}</td><td>${g.total}</td><td>${g.employed}</td><td>${g.relatedEmployed}</td><td>${g.notRelatedEmployed}</td><td>${g.pursuing}</td><td>${g.unemployed}</td>`;
        body.appendChild(tr);
      });
      const sum = groupArray.reduce((acc,g) => {
        acc.total += g.total;
        acc.employed += g.employed;
        acc.related += g.relatedEmployed;
        acc.notrelated += g.notRelatedEmployed;
        acc.pursuing += g.pursuing;
        acc.unemployed += g.unemployed;
        return acc;
      }, {total:0, employed:0, related:0, notrelated:0, pursuing:0, unemployed:0});
      const trSum = document.createElement('tr');
      trSum.innerHTML = `<th colspan="2">Total</th><th>${sum.total}</th><th>${sum.employed}</th><th>${sum.related}</th><th>${sum.notrelated}</th><th>${sum.pursuing}</th><th>${sum.unemployed}</th>`;
      body.appendChild(trSum);

      tbl.appendChild(body);
      tableWrap.appendChild(tbl);

    },
    error: function(err) {
      statusEl.textContent = 'Error loading CSV: ' + err;
    }
  });
})();
</script>
</body>
</html>
